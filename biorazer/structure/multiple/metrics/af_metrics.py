import json, os
import numpy as np

from ..abstracts import StructureStack, Metric

class interface_sidechain_plddts(Metric):
    
    def __init__(self,
            metric_name="interface_sidechain_plddts",
            struc_indices=[0, 1, 2, 3, 4]
        ):
        super().__init__(
            metric_name=metric_name,
            input_file_patterns={
                "full_data": "{0}/fold_{name}_full_data_{i}.json",
                "interface_annotations": "{0}/fold_{name}_model_{i}_interface_annotations.json"
            },
            output_file_patterns={
                "interface_sidechain_plddts": "{0}/fold_{name}_interface_sidechain_plddts.json"
            },
            struc_indices=struc_indices
        )
        
    def calculate(self, struc_stacks: list[StructureStack], overwrite = False):
        
        if not overwrite and os.path.exists(self.get_output_file_path("interface_sidechain_plddts", struc_stacks, 0)):
            return json.load(open(self.get_output_file_path("interface_sidechain_plddts", struc_stacks, 0)))
        
        interface_sidechain_plddts = {}
        for struc_index in self.struc_indices:
            full_data = json.load(open(self.get_input_file_path("full_data", struc_stacks, struc_index)))
            interface_annotations = json.load(open(self.get_input_file_path("interface_annotations", struc_stacks, struc_index)))
            interface_sidechain_indices = interface_annotations["sidechain_indices"]
            interface_sidechain_plddts[struc_index] = np.array(full_data["atom_plddts"])[interface_sidechain_indices].tolist()
        json.dump(interface_sidechain_plddts, open(self.get_output_file_path("interface_sidechain_plddts", struc_stacks, 0), "w"), indent=4)
        return interface_sidechain_plddts

    def clean(self, structure_stacks: StructureStack):
        try:
            os.remove(self.get_output_file_path("interface_sidechain_plddts", structure_stacks, 0))
        except FileNotFoundError:
            pass

# class AFMetric(Metric):
    
#     '''
#     AFMetrics are metrics that are specific to the AlphaFold models.
#     - Normally, you have 5 AlphaFold models for each sequence.
#     '''
    
#     def __init__(
#         self,
#         metric_name="Alphafold metric",
#         metric_files={
#             "meta_data": "0/./fold_{sn}_full_data_{i}.json",
#             "cif": "0/./fold_{sn}_model_{i}.cif",
#             "conf_data": "0/./fold_{sn}_summary_confidences_{i}.json",
#         },
#         indices=[0, 1, 2, 3, 4]
#     ):
#         super().__init__(
#             metric_name=metric_name,
#             metric_files=metric_files,
#             indices=indices
#         )
        
#     def generate_metric_files(self):
#         print("All AFMetrics files are directly generated by AlphaFold.")

# class WholeNormalizedPLDDTMetric(AFMetric):
    
#     '''
#     WholeNormalizedPLDDTMetric 用于对结构整体的 PLDDT 进行评估
#     '''
    
#     def _summarize_metric_vector_for_i(self, sequence_name, sequence_index):
#         super()._summarize_metric_vector_for_i(self, sequence_name, sequence_index)
#         meta_file_path = self.get_metric_file_path("meta_data", sequence_name, sequence_index)
#         plddt = af_utils.MetaFile(meta_file_path).get_data()["atom_plddts"]
#         return np.mean(plddt["atom_plddts"]) / 100

# class PartNormalizedPLDDTMetric(AFMetric, PartAtomMetric):
    
#     '''
#     PartPLDDTMetric 用于对结构的部分 PLDDT 进行评估, 给出这些原子的平均 pLDDT
#     '''
    
#     def __init__(
#         self,
#         project: Project,
#         identifiers,
#         metric_name = "pLDDT for specific atoms",
#         metric_files={
#             "meta_data": "0/./fold_{sn}_full_data_{i}.json",
#             "cif": "0/./fold_{sn}_model_{i}.cif",
#             "conf_data": "0/./fold_{sn}_summary_confidences_{i}.json",
#             "part_atom_indices": "0/./fold_{sn}_part_indices_{i}.json"
#         } 
#     ):
#         PartAtomMetric.__init__(
#             self,
#             project=project,
#             identifiers=identifiers,
#             metric_name=metric_name,
#             metric_files=metric_files
#         )
    
#     def _summarize_metric_vector_for_i(self, sequence_name, sequence_index):
#         super()._summarize_metric_vector_for_i(sequence_name, sequence_index)
#         meta_file_path = self.get_metric_file_path("meta_data", sequence_name, sequence_index)
#         plddt = af_utils.MetaFile(meta_file_path).get_data()["atom_plddts"]
#         plddt = np.array(plddt)
#         part_indice_file_path = self.get_metric_file_path("part_atom_indices", sequence_name, sequence_index)
#         with open(part_indice_file_path, "r") as f:
#             part_indices = json.load(f)["part_indices"]
        
#         part_plddt = plddt[part_indices]
#         return np.mean(part_plddt) / 100

# class PartNormalizedPAEMetric(AFMetric, PartResidueMetric):
    
#     '''
#     PartNormalizedPAEMetrics summarize the average PAE for a specific part of the structure.
#     PAEs are normalized by rescaling from 0~31.75 to 0~1.
#     '''
    
#     def __init__(
#         self,
#         project: Project,
#         identifiers,
#         metric_name = "PAE for specific residues",
#         metric_files={
#             "meta_data": "0/./fold_{sn}_full_data_{i}.json",
#             "cif": "0/./fold_{sn}_model_{i}.cif",
#             "conf_data": "0/./fold_{sn}_summary_confidences_{i}.json",
#             "part_residue_indices": "0/./fold_{sn}_part_residue_indices_{i}.json"
#         }
#     ):
#         PartResidueMetric.__init__(
#             self,
#             project=project,
#             identifiers=identifiers,
#             metric_name=metric_name,
#             metric_files=metric_files
#         )
    
#     def _summarize_metric_vector_for_i(self, sequence_name, sequence_index):
#         super()._summarize_metric_vector_for_i(sequence_name, sequence_index)
#         meta_file_path = self.get_metric_file_path("meta_data", sequence_name, sequence_index)
#         pae = af_utils.MetaFile(meta_file_path).get_data()["pae"]
#         pae /= 31.75
#         part_residue_indices = self.get_part_residue_indices(sequence_name, sequence_index)
#         paes_in_focus = []
#         for x, y in part_residue_indices:
#             paes_in_focus.append(pae[x, y])
#         print(paes_in_focus)
#         return np.mean(paes_in_focus)

# class interface_sidechain_plddt(AFMetric):
#     pass